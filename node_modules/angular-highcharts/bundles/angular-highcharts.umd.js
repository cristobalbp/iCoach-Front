(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('highcharts'), require('rxjs'), require('@angular/core')) :
    typeof define === 'function' && define.amd ? define('angular-highcharts', ['exports', 'highcharts', 'rxjs', '@angular/core'], factory) :
    (factory((global['angular-highcharts'] = {}),global.Highcharts,global.rxjs,global.ng.core));
}(this, (function (exports,Highcharts,rxjs,core) { 'use strict';

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var Chart = /** @class */ (function () {
        function Chart(options) {
            if (options === void 0) {
                options = { series: [] };
            }
            this.options = options;
            this.refSubject = new rxjs.AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
        /**
         * Add Point
         * @param point         Highcharts.DataPoint, number touple or number
         * @param serieIndex    Index position of series. This defaults to 0.
         * @param redraw        Flag whether or not to redraw point. This defaults to true.
         * @param shift         Shift point to the start of series. This defaults to false.
         */
        /**
         * Add Point
         * @param {?} point         Highcharts.DataPoint, number touple or number
         * @param {?=} serieIndex    Index position of series. This defaults to 0.
         * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
         * @param {?=} shift         Shift point to the start of series. This defaults to false.
         * @return {?}
         */
        Chart.prototype.addPoint = /**
         * Add Point
         * @param {?} point         Highcharts.DataPoint, number touple or number
         * @param {?=} serieIndex    Index position of series. This defaults to 0.
         * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
         * @param {?=} shift         Shift point to the start of series. This defaults to false.
         * @return {?}
         */
            function (point, serieIndex, redraw, shift) {
                if (serieIndex === void 0) {
                    serieIndex = 0;
                }
                if (redraw === void 0) {
                    redraw = true;
                }
                if (shift === void 0) {
                    shift = false;
                }
                this.ref$.subscribe(function (chart) {
                    if (chart.series.length > serieIndex) {
                        chart.series[serieIndex].addPoint(point, redraw, shift);
                    }
                });
            };
        /**
         * Add Series
         * @param series         Series Configuration
         * @param redraw        Flag whether or not to redraw series. This defaults to true.
         * @param animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
         */
        /**
         * Add Series
         * @param {?} series         Series Configuration
         * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
         * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
         * @return {?}
         */
        Chart.prototype.addSeries = /**
         * Add Series
         * @param {?} series         Series Configuration
         * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
         * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
         * @return {?}
         */
            function (series, redraw, animation) {
                if (redraw === void 0) {
                    redraw = true;
                }
                if (animation === void 0) {
                    animation = false;
                }
                this.ref$.subscribe(function (chart) {
                    chart.addSeries(series, redraw, animation);
                });
            };
        /**
         * Remove Point
         * @param pointIndex    Index of Point
         * @param serieIndex    Specified Index of Series. Defaults to 0.
         */
        /**
         * Remove Point
         * @param {?} pointIndex    Index of Point
         * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
         * @return {?}
         */
        Chart.prototype.removePoint = /**
         * Remove Point
         * @param {?} pointIndex    Index of Point
         * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
         * @return {?}
         */
            function (pointIndex, serieIndex) {
                if (serieIndex === void 0) {
                    serieIndex = 0;
                }
                this.ref$.subscribe(function (chart) {
                    if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                        chart.series[serieIndex].removePoint(pointIndex, true);
                    }
                });
            };
        /**
         * Remove Series
         * @param seriesIndex    Index position of series to remove.
         */
        /**
         * Remove Series
         * @param {?} seriesIndex    Index position of series to remove.
         * @return {?}
         */
        Chart.prototype.removeSeries = /**
         * Remove Series
         * @param {?} seriesIndex    Index position of series to remove.
         * @return {?}
         */
            function (seriesIndex) {
                this.ref$.subscribe(function (chart) {
                    if (chart.series.length > seriesIndex) {
                        chart.series[seriesIndex].remove(true);
                    }
                });
            };
        /**
         * @param {?} el
         * @return {?}
         */
        Chart.prototype.init = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var _this = this;
                Highcharts.chart(el.nativeElement, this.options, function (chart) {
                    _this.refSubject.next(chart);
                    _this.ref = chart;
                    _this.refSubject.complete();
                });
            };
        /**
         * @return {?}
         */
        Chart.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.ref) {
                    this.options = this.ref.options;
                    this.ref.destroy();
                    this.ref = undefined;
                    // new init subject
                    this.refSubject = new rxjs.AsyncSubject();
                    this.ref$ = this.refSubject.asObservable();
                }
            };
        return Chart;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Felix Itzenplitz. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at
     * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
     */
    var /**
     * @license
     * Copyright Felix Itzenplitz. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at
     * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
     */ MapChart = /** @class */ (function () {
        function MapChart(options) {
            this.options = options;
            this.refSubject = new rxjs.AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
        /**
         * @param {?} el
         * @return {?}
         */
        MapChart.prototype.init = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var _this = this;
                Highcharts.mapChart(el.nativeElement, this.options, function (chart) {
                    _this.refSubject.next(chart);
                    _this.ref = chart;
                    _this.refSubject.complete();
                });
            };
        /**
         * @return {?}
         */
        MapChart.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.ref) {
                    this.options = this.ref.options;
                    this.ref.destroy();
                    this.ref = undefined;
                    // new init subject
                    this.refSubject = new rxjs.AsyncSubject();
                    this.ref$ = this.refSubject.asObservable();
                }
            };
        return MapChart;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /**
     * @license
     * Copyright Felix Itzenplitz. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at
     * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
     *
     * @author Felix Itzenplitz
     * @author Timothy A. Perez (contributor)
     */
    var /**
     * @license
     * Copyright Felix Itzenplitz. All Rights Reserved.
     *
     * Use of this source code is governed by an MIT-style license that can be
     * found in the LICENSE file at
     * https://github.com/cebor/angular-highcharts/blob/master/LICENSE
     *
     * @author Felix Itzenplitz
     * @author Timothy A. Perez (contributor)
     */ StockChart = /** @class */ (function () {
        function StockChart(options) {
            if (options === void 0) {
                options = { series: [] };
            }
            this.options = options;
            this.refSubject = new rxjs.AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
        /**
         * @param {?} el
         * @return {?}
         */
        StockChart.prototype.init = /**
         * @param {?} el
         * @return {?}
         */
            function (el) {
                var _this = this;
                Highcharts.stockChart(el.nativeElement, this.options, function (chart) {
                    _this.refSubject.next(chart);
                    _this.ref = chart;
                    _this.refSubject.complete();
                });
            };
        /**
         * @return {?}
         */
        StockChart.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.ref) {
                    this.options = this.ref.options;
                    this.ref.destroy();
                    this.ref = undefined;
                    // new init subject
                    this.refSubject = new rxjs.AsyncSubject();
                    this.ref$ = this.refSubject.asObservable();
                }
            };
        return StockChart;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ChartDirective = /** @class */ (function () {
        function ChartDirective(el) {
            this.el = el;
        }
        /**
         * @param {?} changes
         * @return {?}
         */
        ChartDirective.prototype.ngOnChanges = /**
         * @param {?} changes
         * @return {?}
         */
            function (changes) {
                if (!changes.chart.isFirstChange()) {
                    this.destroy();
                    this.init();
                }
            };
        /**
         * @return {?}
         */
        ChartDirective.prototype.ngOnInit = /**
         * @return {?}
         */
            function () {
                this.init();
            };
        /**
         * @return {?}
         */
        ChartDirective.prototype.ngOnDestroy = /**
         * @return {?}
         */
            function () {
                this.destroy();
            };
        /**
         * @return {?}
         */
        ChartDirective.prototype.init = /**
         * @return {?}
         */
            function () {
                if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart) {
                    this.chart.init(this.el);
                }
            };
        /**
         * @return {?}
         */
        ChartDirective.prototype.destroy = /**
         * @return {?}
         */
            function () {
                if (this.chart instanceof Chart || this.chart instanceof StockChart || this.chart instanceof MapChart) {
                    this.chart.destroy();
                }
            };
        ChartDirective.decorators = [
            { type: core.Directive, args: [{
                        selector: '[chart]'
                    },] }
        ];
        /** @nocollapse */
        ChartDirective.ctorParameters = function () {
            return [
                { type: core.ElementRef }
            ];
        };
        ChartDirective.propDecorators = {
            chart: [{ type: core.Input }]
        };
        return ChartDirective;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    /** @type {?} */
    var HIGHCHARTS_MODULES = new core.InjectionToken('HighchartsModules');
    var ChartService = /** @class */ (function () {
        function ChartService(chartModules) {
            this.chartModules = chartModules;
        }
        /**
         * @return {?}
         */
        ChartService.prototype.initModules = /**
         * @return {?}
         */
            function () {
                this.chartModules.forEach(function (chartModule) {
                    chartModule(Highcharts);
                });
            };
        ChartService.decorators = [
            { type: core.Injectable }
        ];
        /** @nocollapse */
        ChartService.ctorParameters = function () {
            return [
                { type: Array, decorators: [{ type: core.Inject, args: [HIGHCHARTS_MODULES,] }] }
            ];
        };
        return ChartService;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */
    var ɵ0 = [];
    var ChartModule = /** @class */ (function () {
        function ChartModule(cs) {
            this.cs = cs;
            this.cs.initModules();
        }
        ChartModule.decorators = [
            { type: core.NgModule, args: [{
                        exports: [ChartDirective],
                        declarations: [ChartDirective],
                        providers: [
                            { provide: HIGHCHARTS_MODULES, useValue: ɵ0 },
                            ChartService
                        ]
                    },] }
        ];
        /** @nocollapse */
        ChartModule.ctorParameters = function () {
            return [
                { type: ChartService }
            ];
        };
        return ChartModule;
    }());

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    /**
     * @fileoverview added by tsickle
     * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
     */

    exports.Highcharts = Highcharts;
    exports.ChartModule = ChartModule;
    exports.HIGHCHARTS_MODULES = HIGHCHARTS_MODULES;
    exports.Chart = Chart;
    exports.StockChart = StockChart;
    exports.MapChart = MapChart;
    exports.ɵb = ChartDirective;
    exports.ɵa = ChartService;

    Object.defineProperty(exports, '__esModule', { value: true });

})));

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1oaWdoY2hhcnRzLnVtZC5qcy5tYXAiLCJzb3VyY2VzIjpbIm5nOi8vYW5ndWxhci1oaWdoY2hhcnRzL2xpYi9jaGFydC50cyIsIm5nOi8vYW5ndWxhci1oaWdoY2hhcnRzL2xpYi9tYXBjaGFydC50cyIsIm5nOi8vYW5ndWxhci1oaWdoY2hhcnRzL2xpYi9zdG9ja2NoYXJ0LnRzIiwibmc6Ly9hbmd1bGFyLWhpZ2hjaGFydHMvbGliL2NoYXJ0LmRpcmVjdGl2ZS50cyIsIm5nOi8vYW5ndWxhci1oaWdoY2hhcnRzL2xpYi9jaGFydC5zZXJ2aWNlLnRzIiwibmc6Ly9hbmd1bGFyLWhpZ2hjaGFydHMvbGliL2NoYXJ0Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBc3luY1N1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEhpZ2hjaGFydHMgfSBmcm9tICcuL2hpZ2hjaGFydHMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgRmVsaXggSXR6ZW5wbGl0ei4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2NlYm9yL2FuZ3VsYXItaGlnaGNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKiBAYXV0aG9yIEZlbGl4IEl0emVucGxpdHpcbiAqIEBhdXRob3IgVGltb3RoeSBBLiBQZXJleiAoY29udHJpYnV0b3IpXG4gKi9cbmV4cG9ydCB0eXBlIFBvaW50ID0gbnVtYmVyIHwgW251bWJlciwgbnVtYmVyXSB8IEhpZ2hjaGFydHMuRGF0YVBvaW50O1xuXG5leHBvcnQgY2xhc3MgQ2hhcnQge1xuICBwcml2YXRlIHJlZlN1YmplY3Q6IEFzeW5jU3ViamVjdDxIaWdoY2hhcnRzLkNoYXJ0T2JqZWN0PiA9IG5ldyBBc3luY1N1YmplY3QoKTtcbiAgcmVmJDogT2JzZXJ2YWJsZTxIaWdoY2hhcnRzLkNoYXJ0T2JqZWN0PiA9IHRoaXMucmVmU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgcmVmOiBIaWdoY2hhcnRzLkNoYXJ0T2JqZWN0O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3B0aW9uczogSGlnaGNoYXJ0cy5PcHRpb25zID0geyBzZXJpZXM6IFtdIH0pIHt9XG5cbiAgLyoqXG4gICAqIEFkZCBQb2ludFxuICAgKiBAcGFyYW0gcG9pbnQgICAgICAgICBIaWdoY2hhcnRzLkRhdGFQb2ludCwgbnVtYmVyIHRvdXBsZSBvciBudW1iZXJcbiAgICogQHBhcmFtIHNlcmllSW5kZXggICAgSW5kZXggcG9zaXRpb24gb2Ygc2VyaWVzLiBUaGlzIGRlZmF1bHRzIHRvIDAuXG4gICAqIEBwYXJhbSByZWRyYXcgICAgICAgIEZsYWcgd2hldGhlciBvciBub3QgdG8gcmVkcmF3IHBvaW50LiBUaGlzIGRlZmF1bHRzIHRvIHRydWUuXG4gICAqIEBwYXJhbSBzaGlmdCAgICAgICAgIFNoaWZ0IHBvaW50IHRvIHRoZSBzdGFydCBvZiBzZXJpZXMuIFRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICBhZGRQb2ludChwb2ludDogUG9pbnQsIHNlcmllSW5kZXg6IG51bWJlciA9IDAsIHJlZHJhdzogYm9vbGVhbiA9IHRydWUsIHNoaWZ0OiBib29sZWFuID0gZmFsc2UpOiB2b2lkIHtcbiAgICB0aGlzLnJlZiQuc3Vic2NyaWJlKGNoYXJ0ID0+IHtcbiAgICAgIGlmIChjaGFydC5zZXJpZXMubGVuZ3RoID4gc2VyaWVJbmRleCkge1xuICAgICAgICBjaGFydC5zZXJpZXNbc2VyaWVJbmRleF0uYWRkUG9pbnQocG9pbnQsIHJlZHJhdywgc2hpZnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBTZXJpZXNcbiAgICogQHBhcmFtIHNlcmllcyAgICAgICAgIFNlcmllcyBDb25maWd1cmF0aW9uXG4gICAqIEBwYXJhbSByZWRyYXcgICAgICAgIEZsYWcgd2hldGhlciBvciBub3QgdG8gcmVkcmF3IHNlcmllcy4gVGhpcyBkZWZhdWx0cyB0byB0cnVlLlxuICAgKiBAcGFyYW0gYW5pbWF0aW9uICAgICBXaGV0aGVyIHRvIGFwcGx5IGFuaW1hdGlvbiwgYW5kIG9wdGlvbmFsbHkgYW5pbWF0aW9uIGNvbmZpZ3VyYXRpb24uIFRoaXMgZGVmYXVsdHMgdG8gZmFsc2UuXG4gICAqL1xuICBhZGRTZXJpZXMoXG4gICAgc2VyaWVzOiBIaWdoY2hhcnRzLlNlcmllc09wdGlvbnMsXG4gICAgcmVkcmF3ID0gdHJ1ZSxcbiAgICBhbmltYXRpb246IGJvb2xlYW4gfCBIaWdoY2hhcnRzLkFuaW1hdGlvbiA9IGZhbHNlXG4gICk6IHZvaWQge1xuICAgIHRoaXMucmVmJC5zdWJzY3JpYmUoY2hhcnQgPT4ge1xuICAgICAgY2hhcnQuYWRkU2VyaWVzKHNlcmllcywgcmVkcmF3LCBhbmltYXRpb24pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBQb2ludFxuICAgKiBAcGFyYW0gcG9pbnRJbmRleCAgICBJbmRleCBvZiBQb2ludFxuICAgKiBAcGFyYW0gc2VyaWVJbmRleCAgICBTcGVjaWZpZWQgSW5kZXggb2YgU2VyaWVzLiBEZWZhdWx0cyB0byAwLlxuICAgKi9cbiAgcmVtb3ZlUG9pbnQocG9pbnRJbmRleDogbnVtYmVyLCBzZXJpZUluZGV4ID0gMCk6IHZvaWQge1xuICAgIHRoaXMucmVmJC5zdWJzY3JpYmUoY2hhcnQgPT4ge1xuICAgICAgaWYgKGNoYXJ0LnNlcmllcy5sZW5ndGggPiBzZXJpZUluZGV4ICYmIGNoYXJ0LnNlcmllc1tzZXJpZUluZGV4XS5kYXRhLmxlbmd0aCA+IHBvaW50SW5kZXgpIHtcbiAgICAgICAgY2hhcnQuc2VyaWVzW3NlcmllSW5kZXhdLnJlbW92ZVBvaW50KHBvaW50SW5kZXgsIHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZSBTZXJpZXNcbiAgICogQHBhcmFtIHNlcmllc0luZGV4ICAgIEluZGV4IHBvc2l0aW9uIG9mIHNlcmllcyB0byByZW1vdmUuXG4gICAqL1xuICByZW1vdmVTZXJpZXMoc2VyaWVzSW5kZXg6IG51bWJlcik6IHZvaWQge1xuICAgIHRoaXMucmVmJC5zdWJzY3JpYmUoY2hhcnQgPT4ge1xuICAgICAgaWYgKGNoYXJ0LnNlcmllcy5sZW5ndGggPiBzZXJpZXNJbmRleCkge1xuICAgICAgICBjaGFydC5zZXJpZXNbc2VyaWVzSW5kZXhdLnJlbW92ZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGluaXQoZWw6IEVsZW1lbnRSZWYpOiB2b2lkIHtcbiAgICBIaWdoY2hhcnRzLmNoYXJ0KGVsLm5hdGl2ZUVsZW1lbnQsIHRoaXMub3B0aW9ucywgY2hhcnQgPT4ge1xuICAgICAgdGhpcy5yZWZTdWJqZWN0Lm5leHQoY2hhcnQpO1xuICAgICAgdGhpcy5yZWYgPSBjaGFydDtcbiAgICAgIHRoaXMucmVmU3ViamVjdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucmVmLm9wdGlvbnM7XG4gICAgICB0aGlzLnJlZi5kZXN0cm95KCk7XG4gICAgICB0aGlzLnJlZiA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gbmV3IGluaXQgc3ViamVjdFxuICAgICAgdGhpcy5yZWZTdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICAgICAgdGhpcy5yZWYkID0gdGhpcy5yZWZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiaW1wb3J0IHsgRWxlbWVudFJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQXN5bmNTdWJqZWN0LCBPYnNlcnZhYmxlIH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBIaWdoY2hhcnRzIH0gZnJvbSAnLi9oaWdoY2hhcnRzJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEZlbGl4IEl0emVucGxpdHouIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jZWJvci9hbmd1bGFyLWhpZ2hjaGFydHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5leHBvcnQgY2xhc3MgTWFwQ2hhcnQge1xuICBwcml2YXRlIHJlZlN1YmplY3Q6IEFzeW5jU3ViamVjdDxhbnk+ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICByZWYkOiBPYnNlcnZhYmxlPGFueT4gPSB0aGlzLnJlZlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gIHJlZjogYW55O1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgb3B0aW9ucykge31cblxuICBpbml0KGVsOiBFbGVtZW50UmVmKTogdm9pZCB7XG4gICAgKDxhbnk+SGlnaGNoYXJ0cykubWFwQ2hhcnQoZWwubmF0aXZlRWxlbWVudCwgdGhpcy5vcHRpb25zLCBjaGFydCA9PiB7XG4gICAgICB0aGlzLnJlZlN1YmplY3QubmV4dChjaGFydCk7XG4gICAgICB0aGlzLnJlZiA9IGNoYXJ0O1xuICAgICAgdGhpcy5yZWZTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5yZWYub3B0aW9ucztcbiAgICAgIHRoaXMucmVmLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVmID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBuZXcgaW5pdCBzdWJqZWN0XG4gICAgICB0aGlzLnJlZlN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgICB0aGlzLnJlZiQgPSB0aGlzLnJlZlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICB9XG59XG4iLCJpbXBvcnQgeyBFbGVtZW50UmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBc3luY1N1YmplY3QsIE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEhpZ2hjaGFydHMgfSBmcm9tICcuL2hpZ2hjaGFydHMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgRmVsaXggSXR6ZW5wbGl0ei4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdFxuICogaHR0cHM6Ly9naXRodWIuY29tL2NlYm9yL2FuZ3VsYXItaGlnaGNoYXJ0cy9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogQGF1dGhvciBGZWxpeCBJdHplbnBsaXR6XG4gKiBAYXV0aG9yIFRpbW90aHkgQS4gUGVyZXogKGNvbnRyaWJ1dG9yKVxuICovXG5leHBvcnQgY2xhc3MgU3RvY2tDaGFydCB7XG4gIHByaXZhdGUgcmVmU3ViamVjdDogQXN5bmNTdWJqZWN0PEhpZ2hzdG9jay5DaGFydE9iamVjdD4gPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gIHJlZiQ6IE9ic2VydmFibGU8SGlnaHN0b2NrLkNoYXJ0T2JqZWN0PiA9IHRoaXMucmVmU3ViamVjdC5hc09ic2VydmFibGUoKTtcbiAgcmVmOiBIaWdoc3RvY2suQ2hhcnRPYmplY3Q7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb25zOiBIaWdoc3RvY2suT3B0aW9ucyA9IHsgc2VyaWVzOiBbXSB9KSB7fVxuXG4gIGluaXQoZWw6IEVsZW1lbnRSZWYpOiB2b2lkIHtcbiAgICAoPGFueT5IaWdoY2hhcnRzKS5zdG9ja0NoYXJ0KGVsLm5hdGl2ZUVsZW1lbnQsIHRoaXMub3B0aW9ucywgY2hhcnQgPT4ge1xuICAgICAgdGhpcy5yZWZTdWJqZWN0Lm5leHQoY2hhcnQpO1xuICAgICAgdGhpcy5yZWYgPSBjaGFydDtcbiAgICAgIHRoaXMucmVmU3ViamVjdC5jb21wbGV0ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICBpZiAodGhpcy5yZWYpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMucmVmLm9wdGlvbnM7XG4gICAgICB0aGlzLnJlZi5kZXN0cm95KCk7XG4gICAgICB0aGlzLnJlZiA9IHVuZGVmaW5lZDtcblxuICAgICAgLy8gbmV3IGluaXQgc3ViamVjdFxuICAgICAgdGhpcy5yZWZTdWJqZWN0ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICAgICAgdGhpcy5yZWYkID0gdGhpcy5yZWZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IEZlbGl4IEl0emVucGxpdHouIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlIGxpY2Vuc2UgdGhhdCBjYW4gYmVcbiAqIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9jZWJvci9hbmd1bGFyLWhpZ2hjaGFydHMvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5pbXBvcnQgeyBEaXJlY3RpdmUsIEVsZW1lbnRSZWYsIElucHV0LCBPbkNoYW5nZXMsIE9uRGVzdHJveSwgT25Jbml0LCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDaGFydCB9IGZyb20gJy4vY2hhcnQnO1xuaW1wb3J0IHsgTWFwQ2hhcnQgfSBmcm9tICcuL21hcGNoYXJ0JztcbmltcG9ydCB7IFN0b2NrQ2hhcnQgfSBmcm9tICcuL3N0b2NrY2hhcnQnO1xuXG5ARGlyZWN0aXZlKHtcbiAgc2VsZWN0b3I6ICdbY2hhcnRdJ1xufSlcbmV4cG9ydCBjbGFzcyBDaGFydERpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25EZXN0cm95LCBPbkNoYW5nZXMge1xuICBASW5wdXQoKSBjaGFydDogQ2hhcnQgfCBTdG9ja0NoYXJ0IHwgTWFwQ2hhcnQ7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBlbDogRWxlbWVudFJlZikge31cblxuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgaWYgKCFjaGFuZ2VzLmNoYXJ0LmlzRmlyc3RDaGFuZ2UoKSkge1xuICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICB0aGlzLmluaXQoKTtcbiAgICB9XG4gIH1cblxuICBuZ09uSW5pdCgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIG5nT25EZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbml0KCkge1xuICAgIGlmICh0aGlzLmNoYXJ0IGluc3RhbmNlb2YgQ2hhcnQgfHwgdGhpcy5jaGFydCBpbnN0YW5jZW9mIFN0b2NrQ2hhcnQgfHwgdGhpcy5jaGFydCBpbnN0YW5jZW9mIE1hcENoYXJ0KSB7XG4gICAgICB0aGlzLmNoYXJ0LmluaXQodGhpcy5lbCk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmNoYXJ0IGluc3RhbmNlb2YgQ2hhcnQgfHwgdGhpcy5jaGFydCBpbnN0YW5jZW9mIFN0b2NrQ2hhcnQgfHwgdGhpcy5jaGFydCBpbnN0YW5jZW9mIE1hcENoYXJ0KSB7XG4gICAgICB0aGlzLmNoYXJ0LmRlc3Ryb3koKTtcbiAgICB9XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBGZWxpeCBJdHplbnBsaXR6LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2Vib3IvYW5ndWxhci1oaWdoY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuaW1wb3J0IHsgSW5qZWN0LCBJbmplY3RhYmxlLCBJbmplY3Rpb25Ub2tlbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgSGlnaGNoYXJ0cyB9IGZyb20gJy4vaGlnaGNoYXJ0cyc7XG5cbmV4cG9ydCBsZXQgSElHSENIQVJUU19NT0RVTEVTID0gbmV3IEluamVjdGlvblRva2VuPGFueVtdPignSGlnaGNoYXJ0c01vZHVsZXMnKTtcblxuQEluamVjdGFibGUoKVxuZXhwb3J0IGNsYXNzIENoYXJ0U2VydmljZSB7XG4gIGNvbnN0cnVjdG9yKEBJbmplY3QoSElHSENIQVJUU19NT0RVTEVTKSBwcml2YXRlIGNoYXJ0TW9kdWxlczogYW55W10pIHsgfVxuXG4gIGluaXRNb2R1bGVzKCkge1xuICAgIHRoaXMuY2hhcnRNb2R1bGVzLmZvckVhY2goY2hhcnRNb2R1bGUgPT4ge1xuICAgICAgY2hhcnRNb2R1bGUoSGlnaGNoYXJ0cyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBGZWxpeCBJdHplbnBsaXR6LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2Vib3IvYW5ndWxhci1oaWdoY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqL1xuaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IENoYXJ0RGlyZWN0aXZlIH0gZnJvbSAnLi9jaGFydC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2hhcnRTZXJ2aWNlLCBISUdIQ0hBUlRTX01PRFVMRVMgfSBmcm9tICcuL2NoYXJ0LnNlcnZpY2UnO1xuXG5ATmdNb2R1bGUoe1xuICBleHBvcnRzOiBbQ2hhcnREaXJlY3RpdmVdLFxuICBkZWNsYXJhdGlvbnM6IFtDaGFydERpcmVjdGl2ZV0sXG4gIHByb3ZpZGVyczogW1xuICAgIHsgcHJvdmlkZTogSElHSENIQVJUU19NT0RVTEVTLCB1c2VWYWx1ZTogW10gfSxcbiAgICBDaGFydFNlcnZpY2VcbiAgXVxufSlcbmV4cG9ydCBjbGFzcyBDaGFydE1vZHVsZSB7XG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY3M6IENoYXJ0U2VydmljZSkge1xuICAgIHRoaXMuY3MuaW5pdE1vZHVsZXMoKTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbIkFzeW5jU3ViamVjdCIsIkhpZ2hjaGFydHMuY2hhcnQiLCIoKCAvKiogQHR5cGUgez99ICovKEhpZ2hjaGFydHMpKSkubWFwQ2hhcnQiLCIoKCAvKiogQHR5cGUgez99ICovKEhpZ2hjaGFydHMpKSkuc3RvY2tDaGFydCIsIkRpcmVjdGl2ZSIsIkVsZW1lbnRSZWYiLCJJbnB1dCIsIkluamVjdGlvblRva2VuIiwiSW5qZWN0YWJsZSIsIkluamVjdCIsIk5nTW9kdWxlIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFDQTtRQW9CRSxlQUFvQixPQUE0QztZQUE1Qyx3QkFBQTtnQkFBQSxZQUFnQyxNQUFNLEVBQUUsRUFBRSxFQUFFOztZQUE1QyxZQUFPLEdBQVAsT0FBTyxDQUFxQztZQUp4RCxlQUFVLEdBQXlDLElBQUlBLGlCQUFZLEVBQUUsQ0FBQztZQUM5RSxTQUFJLEdBQXVDLElBQUksQ0FBQyxV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
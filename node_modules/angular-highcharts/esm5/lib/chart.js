/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,uselessCode} checked by tsc
 */
import { AsyncSubject } from 'rxjs';
import { Highcharts } from './highcharts';
var Chart = /** @class */ (function () {
    function Chart(options) {
        if (options === void 0) { options = { series: [] }; }
        this.options = options;
        this.refSubject = new AsyncSubject();
        this.ref$ = this.refSubject.asObservable();
    }
    /**
     * Add Point
     * @param point         Highcharts.DataPoint, number touple or number
     * @param serieIndex    Index position of series. This defaults to 0.
     * @param redraw        Flag whether or not to redraw point. This defaults to true.
     * @param shift         Shift point to the start of series. This defaults to false.
     */
    /**
     * Add Point
     * @param {?} point         Highcharts.DataPoint, number touple or number
     * @param {?=} serieIndex    Index position of series. This defaults to 0.
     * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
     * @param {?=} shift         Shift point to the start of series. This defaults to false.
     * @return {?}
     */
    Chart.prototype.addPoint = /**
     * Add Point
     * @param {?} point         Highcharts.DataPoint, number touple or number
     * @param {?=} serieIndex    Index position of series. This defaults to 0.
     * @param {?=} redraw        Flag whether or not to redraw point. This defaults to true.
     * @param {?=} shift         Shift point to the start of series. This defaults to false.
     * @return {?}
     */
    function (point, serieIndex, redraw, shift) {
        if (serieIndex === void 0) { serieIndex = 0; }
        if (redraw === void 0) { redraw = true; }
        if (shift === void 0) { shift = false; }
        this.ref$.subscribe(function (chart) {
            if (chart.series.length > serieIndex) {
                chart.series[serieIndex].addPoint(point, redraw, shift);
            }
        });
    };
    /**
     * Add Series
     * @param series         Series Configuration
     * @param redraw        Flag whether or not to redraw series. This defaults to true.
     * @param animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     */
    /**
     * Add Series
     * @param {?} series         Series Configuration
     * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
     * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     * @return {?}
     */
    Chart.prototype.addSeries = /**
     * Add Series
     * @param {?} series         Series Configuration
     * @param {?=} redraw        Flag whether or not to redraw series. This defaults to true.
     * @param {?=} animation     Whether to apply animation, and optionally animation configuration. This defaults to false.
     * @return {?}
     */
    function (series, redraw, animation) {
        if (redraw === void 0) { redraw = true; }
        if (animation === void 0) { animation = false; }
        this.ref$.subscribe(function (chart) {
            chart.addSeries(series, redraw, animation);
        });
    };
    /**
     * Remove Point
     * @param pointIndex    Index of Point
     * @param serieIndex    Specified Index of Series. Defaults to 0.
     */
    /**
     * Remove Point
     * @param {?} pointIndex    Index of Point
     * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
     * @return {?}
     */
    Chart.prototype.removePoint = /**
     * Remove Point
     * @param {?} pointIndex    Index of Point
     * @param {?=} serieIndex    Specified Index of Series. Defaults to 0.
     * @return {?}
     */
    function (pointIndex, serieIndex) {
        if (serieIndex === void 0) { serieIndex = 0; }
        this.ref$.subscribe(function (chart) {
            if (chart.series.length > serieIndex && chart.series[serieIndex].data.length > pointIndex) {
                chart.series[serieIndex].removePoint(pointIndex, true);
            }
        });
    };
    /**
     * Remove Series
     * @param seriesIndex    Index position of series to remove.
     */
    /**
     * Remove Series
     * @param {?} seriesIndex    Index position of series to remove.
     * @return {?}
     */
    Chart.prototype.removeSeries = /**
     * Remove Series
     * @param {?} seriesIndex    Index position of series to remove.
     * @return {?}
     */
    function (seriesIndex) {
        this.ref$.subscribe(function (chart) {
            if (chart.series.length > seriesIndex) {
                chart.series[seriesIndex].remove(true);
            }
        });
    };
    /**
     * @param {?} el
     * @return {?}
     */
    Chart.prototype.init = /**
     * @param {?} el
     * @return {?}
     */
    function (el) {
        var _this = this;
        Highcharts.chart(el.nativeElement, this.options, function (chart) {
            _this.refSubject.next(chart);
            _this.ref = chart;
            _this.refSubject.complete();
        });
    };
    /**
     * @return {?}
     */
    Chart.prototype.destroy = /**
     * @return {?}
     */
    function () {
        if (this.ref) {
            this.options = this.ref.options;
            this.ref.destroy();
            this.ref = undefined;
            // new init subject
            this.refSubject = new AsyncSubject();
            this.ref$ = this.refSubject.asObservable();
        }
    };
    return Chart;
}());
export { Chart };
if (false) {
    /** @type {?} */
    Chart.prototype.refSubject;
    /** @type {?} */
    Chart.prototype.ref$;
    /** @type {?} */
    Chart.prototype.ref;
    /** @type {?} */
    Chart.prototype.options;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY2hhcnQuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9hbmd1bGFyLWhpZ2hjaGFydHMvIiwic291cmNlcyI6WyJsaWIvY2hhcnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUNBLE9BQU8sRUFBRSxZQUFZLEVBQWMsTUFBTSxNQUFNLENBQUM7QUFDaEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGNBQWMsQ0FBQztBQWMxQztJQUtFLGVBQW9CLE9BQTRDO1FBQTVDLHdCQUFBLEVBQUEsWUFBZ0MsTUFBTSxFQUFFLEVBQUUsRUFBRTtRQUE1QyxZQUFPLEdBQVAsT0FBTyxDQUFxQztRQUp4RCxlQUFVLEdBQXlDLElBQUksWUFBWSxFQUFFLENBQUM7UUFDOUUsU0FBSSxHQUF1QyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO0lBR1AsQ0FBQztJQUVwRTs7Ozs7O09BTUc7Ozs7Ozs7OztJQUNILHdCQUFROzs7Ozs7OztJQUFSLFVBQVMsS0FBWSxFQUFFLFVBQXNCLEVBQUUsTUFBc0IsRUFBRSxLQUFzQjtRQUF0RSwyQkFBQSxFQUFBLGNBQXNCO1FBQUUsdUJBQUEsRUFBQSxhQUFzQjtRQUFFLHNCQUFBLEVBQUEsYUFBc0I7UUFDM0YsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBQSxLQUFLO1lBQ3ZCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsVUFBVSxFQUFFO2dCQUNwQyxLQUFLLENBQUMsTUFBTSxDQUFDLFVBQVUsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxLQUFLLEVBQUUsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDO2FBQ3pEO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDO0lBRUQ7Ozs7O09BS0c7Ozs7Ozs7O0lBQ0gseUJBQVM7Ozs7Ozs7SUFBVCxVQUNFLE1BQWdDLEVBQ2hDLE1BQWEsRUFDYixTQUFpRDtRQURqRCx1QkFBQSxFQUFBLGFBQWE7UUFDYiwwQkFBQSxFQUFBLGlCQUFpRDtRQUVqRCxJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFBLEtBQUs7WUFDdkIsS0FBSyxDQUFDLFNBQVMsQ0FBQyxNQUFNLEVBQUUsTUFBTSxFQUFFLFNBQVMsQ0FBQyxDQUFDO1FBQzdDLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7O09BSUc7Ozs7Ozs7SUFDSCwyQkFBVzs7Ozs7O0lBQVgsVUFBWSxVQUFrQixFQUFFLFVBQWM7UUFBZCwyQkFBQSxFQUFBLGNBQWM7UUFDNUMsSUFBSSxDQUFDLElBQUksQ0FBQyxTQUFTLENBQUMsVUFBQSxLQUFLO1lBQ3ZCLElBQUksS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsVUFBVSxJQUFJLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLE1BQU0sR0FBRyxVQUFVLEVBQUU7Z0JBQ3pGLEtBQUssQ0FBQyxNQUFNLENBQUMsVUFBVSxDQUFDLENBQUMsV0FBVyxDQUFDLFVBQVUsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUN4RDtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVEOzs7T0FHRzs7Ozs7O0lBQ0gsNEJBQVk7Ozs7O0lBQVosVUFBYSxXQUFtQjtRQUM5QixJQUFJLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxVQUFBLEtBQUs7WUFDdkIsSUFBSSxLQUFLLENBQUMsTUFBTSxDQUFDLE1BQU0sR0FBRyxXQUFXLEVBQUU7Z0JBQ3JDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDO2FBQ3hDO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOzs7OztJQUVELG9CQUFJOzs7O0lBQUosVUFBSyxFQUFjO1FBQW5CLGlCQU1DO1FBTEMsVUFBVSxDQUFDLEtBQUssQ0FBQyxFQUFFLENBQUMsYUFBYSxFQUFFLElBQUksQ0FBQyxPQUFPLEVBQUUsVUFBQSxLQUFLO1lBQ3BELEtBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1lBQzVCLEtBQUksQ0FBQyxHQUFHLEdBQUcsS0FBSyxDQUFDO1lBQ2pCLEtBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7UUFDN0IsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDOzs7O0lBRUQsdUJBQU87OztJQUFQO1FBQ0UsSUFBSSxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ1osSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQztZQUNoQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sRUFBRSxDQUFDO1lBQ25CLElBQUksQ0FBQyxHQUFHLEdBQUcsU0FBUyxDQUFDO1lBRXJCLG1CQUFtQjtZQUNuQixJQUFJLENBQUMsVUFBVSxHQUFHLElBQUksWUFBWSxFQUFFLENBQUM7WUFDckMsSUFBSSxDQUFDLElBQUksR0FBRyxJQUFJLENBQUMsVUFBVSxDQUFDLFlBQVksRUFBRSxDQUFDO1NBQzVDO0lBQ0gsQ0FBQztJQUNILFlBQUM7QUFBRCxDQUFDLEFBbEZELElBa0ZDOzs7O0lBakZDLDJCQUE4RTs7SUFDOUUscUJBQTBFOztJQUMxRSxvQkFBNEI7O0lBRWhCLHdCQUFvRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEVsZW1lbnRSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFzeW5jU3ViamVjdCwgT2JzZXJ2YWJsZSB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgSGlnaGNoYXJ0cyB9IGZyb20gJy4vaGlnaGNoYXJ0cyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCBGZWxpeCBJdHplbnBsaXR6LiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZSBsaWNlbnNlIHRoYXQgY2FuIGJlXG4gKiBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIGF0XG4gKiBodHRwczovL2dpdGh1Yi5jb20vY2Vib3IvYW5ndWxhci1oaWdoY2hhcnRzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbiAqIEBhdXRob3IgRmVsaXggSXR6ZW5wbGl0elxuICogQGF1dGhvciBUaW1vdGh5IEEuIFBlcmV6IChjb250cmlidXRvcilcbiAqL1xuZXhwb3J0IHR5cGUgUG9pbnQgPSBudW1iZXIgfCBbbnVtYmVyLCBudW1iZXJdIHwgSGlnaGNoYXJ0cy5EYXRhUG9pbnQ7XG5cbmV4cG9ydCBjbGFzcyBDaGFydCB7XG4gIHByaXZhdGUgcmVmU3ViamVjdDogQXN5bmNTdWJqZWN0PEhpZ2hjaGFydHMuQ2hhcnRPYmplY3Q+ID0gbmV3IEFzeW5jU3ViamVjdCgpO1xuICByZWYkOiBPYnNlcnZhYmxlPEhpZ2hjaGFydHMuQ2hhcnRPYmplY3Q+ID0gdGhpcy5yZWZTdWJqZWN0LmFzT2JzZXJ2YWJsZSgpO1xuICByZWY6IEhpZ2hjaGFydHMuQ2hhcnRPYmplY3Q7XG5cbiAgY29uc3RydWN0b3IocHJpdmF0ZSBvcHRpb25zOiBIaWdoY2hhcnRzLk9wdGlvbnMgPSB7IHNlcmllczogW10gfSkge31cblxuICAvKipcbiAgICogQWRkIFBvaW50XG4gICAqIEBwYXJhbSBwb2ludCAgICAgICAgIEhpZ2hjaGFydHMuRGF0YVBvaW50LCBudW1iZXIgdG91cGxlIG9yIG51bWJlclxuICAgKiBAcGFyYW0gc2VyaWVJbmRleCAgICBJbmRleCBwb3NpdGlvbiBvZiBzZXJpZXMuIFRoaXMgZGVmYXVsdHMgdG8gMC5cbiAgICogQHBhcmFtIHJlZHJhdyAgICAgICAgRmxhZyB3aGV0aGVyIG9yIG5vdCB0byByZWRyYXcgcG9pbnQuIFRoaXMgZGVmYXVsdHMgdG8gdHJ1ZS5cbiAgICogQHBhcmFtIHNoaWZ0ICAgICAgICAgU2hpZnQgcG9pbnQgdG8gdGhlIHN0YXJ0IG9mIHNlcmllcy4gVGhpcyBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICovXG4gIGFkZFBvaW50KHBvaW50OiBQb2ludCwgc2VyaWVJbmRleDogbnVtYmVyID0gMCwgcmVkcmF3OiBib29sZWFuID0gdHJ1ZSwgc2hpZnQ6IGJvb2xlYW4gPSBmYWxzZSk6IHZvaWQge1xuICAgIHRoaXMucmVmJC5zdWJzY3JpYmUoY2hhcnQgPT4ge1xuICAgICAgaWYgKGNoYXJ0LnNlcmllcy5sZW5ndGggPiBzZXJpZUluZGV4KSB7XG4gICAgICAgIGNoYXJ0LnNlcmllc1tzZXJpZUluZGV4XS5hZGRQb2ludChwb2ludCwgcmVkcmF3LCBzaGlmdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQWRkIFNlcmllc1xuICAgKiBAcGFyYW0gc2VyaWVzICAgICAgICAgU2VyaWVzIENvbmZpZ3VyYXRpb25cbiAgICogQHBhcmFtIHJlZHJhdyAgICAgICAgRmxhZyB3aGV0aGVyIG9yIG5vdCB0byByZWRyYXcgc2VyaWVzLiBUaGlzIGRlZmF1bHRzIHRvIHRydWUuXG4gICAqIEBwYXJhbSBhbmltYXRpb24gICAgIFdoZXRoZXIgdG8gYXBwbHkgYW5pbWF0aW9uLCBhbmQgb3B0aW9uYWxseSBhbmltYXRpb24gY29uZmlndXJhdGlvbi4gVGhpcyBkZWZhdWx0cyB0byBmYWxzZS5cbiAgICovXG4gIGFkZFNlcmllcyhcbiAgICBzZXJpZXM6IEhpZ2hjaGFydHMuU2VyaWVzT3B0aW9ucyxcbiAgICByZWRyYXcgPSB0cnVlLFxuICAgIGFuaW1hdGlvbjogYm9vbGVhbiB8IEhpZ2hjaGFydHMuQW5pbWF0aW9uID0gZmFsc2VcbiAgKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBjaGFydC5hZGRTZXJpZXMoc2VyaWVzLCByZWRyYXcsIGFuaW1hdGlvbik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIFBvaW50XG4gICAqIEBwYXJhbSBwb2ludEluZGV4ICAgIEluZGV4IG9mIFBvaW50XG4gICAqIEBwYXJhbSBzZXJpZUluZGV4ICAgIFNwZWNpZmllZCBJbmRleCBvZiBTZXJpZXMuIERlZmF1bHRzIHRvIDAuXG4gICAqL1xuICByZW1vdmVQb2ludChwb2ludEluZGV4OiBudW1iZXIsIHNlcmllSW5kZXggPSAwKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBpZiAoY2hhcnQuc2VyaWVzLmxlbmd0aCA+IHNlcmllSW5kZXggJiYgY2hhcnQuc2VyaWVzW3NlcmllSW5kZXhdLmRhdGEubGVuZ3RoID4gcG9pbnRJbmRleCkge1xuICAgICAgICBjaGFydC5zZXJpZXNbc2VyaWVJbmRleF0ucmVtb3ZlUG9pbnQocG9pbnRJbmRleCwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIFNlcmllc1xuICAgKiBAcGFyYW0gc2VyaWVzSW5kZXggICAgSW5kZXggcG9zaXRpb24gb2Ygc2VyaWVzIHRvIHJlbW92ZS5cbiAgICovXG4gIHJlbW92ZVNlcmllcyhzZXJpZXNJbmRleDogbnVtYmVyKTogdm9pZCB7XG4gICAgdGhpcy5yZWYkLnN1YnNjcmliZShjaGFydCA9PiB7XG4gICAgICBpZiAoY2hhcnQuc2VyaWVzLmxlbmd0aCA+IHNlcmllc0luZGV4KSB7XG4gICAgICAgIGNoYXJ0LnNlcmllc1tzZXJpZXNJbmRleF0ucmVtb3ZlKHRydWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaW5pdChlbDogRWxlbWVudFJlZik6IHZvaWQge1xuICAgIEhpZ2hjaGFydHMuY2hhcnQoZWwubmF0aXZlRWxlbWVudCwgdGhpcy5vcHRpb25zLCBjaGFydCA9PiB7XG4gICAgICB0aGlzLnJlZlN1YmplY3QubmV4dChjaGFydCk7XG4gICAgICB0aGlzLnJlZiA9IGNoYXJ0O1xuICAgICAgdGhpcy5yZWZTdWJqZWN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLnJlZikge1xuICAgICAgdGhpcy5vcHRpb25zID0gdGhpcy5yZWYub3B0aW9ucztcbiAgICAgIHRoaXMucmVmLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMucmVmID0gdW5kZWZpbmVkO1xuXG4gICAgICAvLyBuZXcgaW5pdCBzdWJqZWN0XG4gICAgICB0aGlzLnJlZlN1YmplY3QgPSBuZXcgQXN5bmNTdWJqZWN0KCk7XG4gICAgICB0aGlzLnJlZiQgPSB0aGlzLnJlZlN1YmplY3QuYXNPYnNlcnZhYmxlKCk7XG4gICAgfVxuICB9XG59XG4iXX0=